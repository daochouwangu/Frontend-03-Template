<style>
  .cell {
    display: inline-block;
    width:6px;
    height:6px;
    background-color: rgb(235, 227, 227);
    border-bottom: solid 1px white;
    border-right: solid 1px white;
    vertical-align: middle;
  }
  #container{
    width:701px;
  }
</style>
<div id="container"></div>
<button onclick="localStorage['map'] = JSON.stringify(map)">save</button>
<button onclick="window.clear()">clear</button>
<button onclick="findPath()">findPath</button>
<input type="checkbox" onchange="changemode()" >擦除模式</input>
<script>
  function clear() {
    localStorage["map"] =  JSON.stringify(Array(10000).fill(0));
  }
  // 初始化
  let map = localStorage["map"] ? JSON.parse(localStorage["map"]) : Array(10000).fill(0);
  // 清楚上一次路径
  for (let i in map) {
    map[i] = map[i] === 1 ? 1 : 0;
  }
  localStorage["map"] =  JSON.stringify(map);
  let container = document.getElementById("container");
  let mousedown = false;
  let points = Array(10000).fill(null);
  let mode = 1;
  function changemode() {
    mode = 1- mode;
  }
  document.addEventListener("mousedown", e => {
    mousedown = true;
  })
  document.addEventListener("mouseup", e => {
    mousedown = false;
  })
  function sleep(delay) {
    return new Promise((resolve) => setTimeout(resolve, delay))
  }
  class Point{
    constructor(x,y,gDis, hDis){
      this.x = x;
      this.y = y;
      this.gDis = gDis;
      this.hDis = hDis;
    }
    get fDis() {
      return this.gDis+this.hDis
    }
    get index() {
      return this.x + this.y*100
    }
  }
  class Sorted {
    constructor(data, compare) {
      this.data = data.slice();
      this.compare = compare || ((a, b) => a - b);
    }
    take() {
      if (!this.data.length)
        return;
      if (this.data.length === 1) {
        return this.data.pop();
      }
      let min = this.data[0];
      let minIndex = 0;
      for (let i = 1; i < this.data.length; i++) {
        if (this.compare(this.data[i], min) < 0) {
          min = this.data[i];
          minIndex = i;
        }
      }
      if (minIndex === this.data.length - 1) {
        return this.data.pop()
      }
      this.data[minIndex] = this.data.pop();
      return min;
    }
    give(v) {
      this.data.push(v);
    }
    get length() {
      return this.data.length
    }
  }
  // 用fragment提升性能
  let frag = document.createDocumentFragment();
  for (let y = 0;y < 100; y++) {
    for (let x = 0; x < 100; x++) {
      let cell = document.createElement("div");
      cell.classList.add("cell");
      if(map[100*y + x] === 1) {
        cell.style.backgroundColor = "black"
      }
      cell.addEventListener("mousemove", () => {
        if (mousedown) {
          if (mode) {
            cell.style.backgroundColor = "black"
            map[100*y + x] = 1
          } else {
            cell.style.backgroundColor = "rgb(235, 227, 227)"
            map[100*y + x] = 0
          }
          
        }
      })
      frag.appendChild(cell)
    }
  }
  class BinaryHeap{
    constructor(data, compare) {
      this.data = data;
      this.compare = compare;
    }
    take(){
      if(!this.data.length) {
        return;
      }
      let min = this.data[0];
      let i = 0;
      while(i < this.data.length) {
        if (i * 2 + 1 >= this.data.length) {
          break;
        }
        if (i * 2 + 2 >= this.data.length) {
          this.data[i] = this.data[i*2+1];
          i = i*2+1;
          break;
        }
        if (this.compare(this.data[i*2+1], this.data[i*2+2]) < 0) {
          this.data[i] = this.data[i*2+1];
          i = i*2+1;
        } else {
          this.data[i] = this.data[i*2+2];
          i = i*2+2;
        }
      }
      if (i < this.data.length - 1) {
        this.insertAt(i, this.data.pop());
      } else {
        this.data.pop();
      }
      return min;
    }
    insertAt(i, v) {
      this.data[i] = v;
      while(i > 0 && this.compare(v, this.data[Math.floor((i-1)/2)]) < 0) {
        this.data[i] = this.data[Math.floor((i-1) /2)];
        this.data[Math.floor((i-1)/2)] = v;
        i = Math.floor((i-1)/2);
      }
    }
    give(v) {
      this.insertAt(this.data.length, v);
    }
    get length() {
      return this.data.length
    }
  }
  // A* g(n) + h(n)
  // g(n) 为实际距离 从gDistance中获得
  function compare(a,b) {
    return a.fDis - b.fDis;
  }
  // g(n) = 0
  // function compare(a,b) {
  //   return distance(a, this.end) - distance(b, this.end);
  // }
  
  function getHdistance(point1, point2) {
    // return Math.max(Math.abs(point1.x-point2.x), Math.abs(point1.y-point2.y))
    return Math.sqrt((point1.x-point2.x)**2 + (point1.y - point2.y)**2)
  }
  Array.prototype.take = Array.prototype.shift
  Array.prototype.give = Array.prototype.push
  async function findPath(start=[0,0], end=[50,50]) {
    let _map = map;
    // 初始距离
    // gDistance[start[0] + start[1]*100] = 0;
    localStorage['map'] = JSON.stringify(map)
    // let queue = new Sorted([start], getCompare(end, gDistance));
    let endPoint = new Point(end[0], end[1], 0,0)
    let startPoint = new Point(start[0], start[1], 0, getHdistance({x:start[0], y:start[1]}, endPoint))
    points[0] = startPoint;
    let queue = new BinaryHeap([startPoint], compare);
    // let queue = [startPoint];
    
    let s = start[0] + start[1]*100;
    let e = end[0] + end[1]*100
    let table = Object.create(map)
    _map[s] = 4;
    _map[e] = 5;
    container.children[s].style.backgroundColor = "blue"
    container.children[e].style.backgroundColor = "red"

    async function insert(x, y, pre, pdis) {
      
      if (x < 0 || x >= 100 || y < 0 || y >= 100) {
        return false;
      }
      let v = y*100 +x
      let point = points[v];
      if (!point) {
        point = new Point(x,y,pdis+1,getHdistance({x,y}, endPoint));
      }
      if (x === end[0] && y === end[1]) {
        table[v] = pre
        queue.give(point);
        return true;
      }
      
      if (_map[v] == 1 || _map[v] == 3) {
        return false;
      } else if (_map[v] == 2) {
        
        if (point.gDis > pdis + 1) {
          point.gDis = pdis+1
          table[v] = pre;
        }
        return false;
      }
      // await sleep(1)
      points[v] = point;
      table[v] = pre;
      // 2表示在open list中
      _map[v] = 2;
      container.children[v].style.backgroundColor = "lightgreen"
      queue.give(point);
      return false;
    }
    
    while(queue.length !== 0) {
      let {x, y, index, gDis} = queue.take();
      // 3表示为在closelist
      _map[index] = 3;
      if (x === end[0] && y === end[1]) {
        let path = [];
        while(x!==start[0] || y != start[1]) {
          path.push(index);
          // container.children[v].style.backgroundColor = "red";
          ;[x,y] = table[index];
           index= y*100+x;
        }
        for (let i of path.reverse()) {
          await sleep(10)
          container.children[i].style.backgroundColor = "red";
        }
        let p = document.createElement('p');
        p.textContent = `路径长:${path.length}`
        document.body.appendChild(p)
        return path;
      }
       await insert(x-1, y,[x,y],gDis);
       await insert(x+1, y,[x,y],gDis);
       await insert(x, y-1,[x,y],gDis);
       await insert(x, y+1,[x,y],gDis);
      //  await insert(x-1, y-1,[x,y],gDis);
      //  await insert(x+1, y+1,[x,y],gDis);
      //  await insert(x+1, y-1,[x,y],gDis);
      //  await insert(x-1, y+1,[x,y],gDis);
      //  queue.sort(compare)
    }
    return null;
  }
  container.append(frag)
</script>
