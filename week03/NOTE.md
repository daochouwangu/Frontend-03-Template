# 学习笔记

## parse 模块

1. 拆分文件，方便管理
2. 定义parseBody函数 接受文本 返回dom树
3. （options）真正的浏览器是异步分段解析response的
4. 用状态机解析HTML,使用EOF（symbol）来区别末尾
5. 标签主要分三种：开始标签、结束标签、自封闭标签
6. 在状态机中加入业务逻辑。（这里是加入emit）
  （根据@三钻的提示 在beforeAtttributeName function里加入selfClosingStartTag的判断 加入漏掉的两处emit）

7. 属性分为单引号，双引号，无引号，要分别处理。处理方式和标签蕾丝，属性结束时，把属性加到标签Token上

8. 从标签构建dom树的基本操作是使用栈
9. 遇到开始标签时创建元素并入栈，遇到结束标签时出栈
10. 自封闭节点可视为入栈后立刻出栈
11. 任何元素的父元素是他入栈前的栈顶元素
12. 暂不处理link 
13. 遇到style标签，就调用css库的parser来解析规则，保存解析出来的rules
14. 需要仔细分析css库解析css的格式！
15. 创建一个元素的时候，立即计算css
16. 理论上，分析一个元素的时候，假设所有css规则已经收集完毕
17. 在真实浏览器中，存在body中的style标签，需要重新计算css，这里我们忽略
18. 在computeCSS函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配
19. 从上一步骤的stack中，就可以轻易获取本元素的所有父元素 
20. 从效率来看，从内到外匹配元素效率最高，举例：div div #myid 先匹配myid
21. TODO 复合选择器
22. 复杂选择器拆分成针对单个元素的选择器，用循环匹配父元素队列
23. 根据选择器的类型和元素属性，计算是否与当前元素匹配
24. 一旦选择匹配，就应用选择到元素上，形成computedStyle
25. specificity计算：
    [0, 0, 0,  0]
    inline id class tag
    div #my #id
    [0,2,0,1]
26. css规则根据specificity和后来优先规则覆盖
27. specificity是个4元组，越左权重越高
28. 一个css规则的specificity根据包含的简单选择器想家而成

