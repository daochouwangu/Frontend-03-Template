# 第9周作业及笔记

## 作业

[迷宫路径](index.html)

## 笔记

其实这些都在极客时间的《数据结构与算法之美》上学过,不过用前端可视化的展示出来,理解的更深了一些.

聊一下A*算法,A*算法是一种启发搜索算法. 在此算法中,如果用g(n)表示起点到任意顶点的实际距离, h(n)表示任意顶点到目标顶点的估算距离,那么A*算法的估算函数就是f(n)= g(n)+h(n)
估算函数分3种情况:

1. g(n)为0 即只计算任意顶点n到目标的评估函数h(n), 不计算起点到顶点的距离,则算法变成贪心策略的最良优先算法,速度最快,但是找不到最优解.
2. h(n)不大于顶点n到目标顶点的实际距离, 则一定可以算出最优解,而且h(n)越小,计算的节点越多,算法效率越低,常见的评估函数有欧几里得算法、曼哈顿距离、切比雪夫距离
3. 如果h(n)为0 即只计算起点到任意顶点的最短路径g(n),而不计算评估函数,则转化为单源最短路径问题,即Dijkstra算法,此时需要计算最多的顶点.

课程里用了两种方法,第一种BFS 其实就是Dijkstar算法,因为图中的所有路径权重一样,就是A算法里的第一种,一定能找到最优解,但是最慢. 第二种就是用欧几里得计算距离,但是只计算终点和当前坐标,即g(n)为0,找不到最优解

改进:
1. 加入g(n)函数
>`g([a,b]) = Math.max(Math.abs(a[0]-b[0]), Math.abs(a[1]-b[1]))`

2. 当前节点进入队列的时候 ,判断周围的点是否已经进入,已经进入的话重新计算g(n),没进入的话进入队列

注意:gn 和 hn应该用同一种计算方式,且gn为实际距离,hn为估算距离,如果hn为欧几里得距离,且未开方,那么gn应该也是欧几里得距离不开方

拓展:

ARA*算法:
先使用宽泛的边界计算,然后逐步收紧边界,这种算法的优势在于可以很快给出一个较优解,并可以逐步优化,可以随时停止.

## 启发式算法在React中的使用
这种按人的经验总结的算法 都叫做启发式算法,在前端中,React 的dom diff 算法就是启发算法,时间复杂度直接从常规的O(n^3) 优化到了 O(n), 这个算法基于2个假设:
1. 两个DOM NODE type不同则一定不同
2. 用属性key来表示子元素的稳定

同时React做dom diff的时候只做同级比较.
这两个假设基本覆盖了大部分情况. 帮助React从性能上优化了一大步.
